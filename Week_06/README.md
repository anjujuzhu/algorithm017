学习笔记
### 动态规划
#### 经典dp
 - Fibonacci数列，递归解法下复杂度指数级的（如果不保存中间状态）

- 递归 自顶向下
- 递推 自底向上的循环-->dp ~ 动态递推

#### dp关键点
 - 1. 最优子结构 opt[n] = best_of(opt[n - 1], opt[n - 2]...)
 - 2. 存储中间状态 opt[i]
    - 一般是要开辟一个数组来存储中间状态
        - 分治中是将状态带到下一层递归中
 - 3. 递推公式 (dp方程、状态转移方程)
    二维路径 opt[i, j] = opt[i + 1, j] + opt[i, j + 1](判断i, j是否为空地)

#### 经验
  - 遇到两个字符串的问题，经验是开辟一个二维数组，一个放在列，一个放在行

### DP 步骤
 1. 重复性
 2. 定义状态数组
 3. dp方程

### dp习题
 - 爬楼梯 变形题
  - f[n] = f[n - 1] + f[n - 2]
   - f[0] = 0, f[1] = 1, f[2] = 2;
    - 可以走1、2、3步
      - f[n] = f[n - 1] + f[n - 2] + f[n - 3]
       - f[0] = 0, f[1] = 1, f[2] = 2;
    - 相邻两步的步伐不能相同
      - 

### 打家劫舍I
 - 延伸一维来存储偷或不偷的状态
  - dp方程
   - 0 ： 不偷； 1 ： 偷；
    - a[i][0] = max(a[i - 1][0], a[i - 1][1])
    - a[i][1] = a[i - 1][0] + nums[i]
   - or
    - a[i] = max(a[i - 1], a[i - 2] + nums[i], a[i - 3] + nums[i]....) 
    - 由于a[i] >= a[i - 1]，因此简化为
    - a[i] = max(a[i - 1], a[i - 2] + nums[i])
   - or
    - 可以看出a[i] 只用到 a[i - 1] && a[i - 2]两个状态，因此可以只开辟两个向量存储中间状态
### 打家劫舍II
  - 转化为两个单列不循环的打家劫舍
   - 包含第一个，去除最后一个
   - 包含最后一个，去除第一个
   - 取两者的max